<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Whack-a-Word ¬∑ The Nomad Kitchen</title>
<link href="https://fonts.googleapis.com/css2?family=Lilita+One&family=Nunito:wght@400;600;700;800;900&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #1a1200;
    --surface: #2a1e00;
    --surface2: #352800;
    --orange: #ff9500;
    --yellow: #ffd60a;
    --red: #ff3b30;
    --green: #34c759;
    --teal: #00e5c8;
    --text: #fff8e8;
    --muted: #a89060;
    --border: rgba(255,180,0,0.15);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Nunito', sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: hidden;
  }

  /* Spice pattern background */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      radial-gradient(circle at 15% 20%, rgba(255,149,0,0.08) 0%, transparent 40%),
      radial-gradient(circle at 85% 80%, rgba(255,60,0,0.06) 0%, transparent 40%),
      radial-gradient(circle at 50% 50%, rgba(255,214,10,0.04) 0%, transparent 60%);
    pointer-events: none;
  }

  /* ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ */
  header {
    width: 100%;
    background: linear-gradient(135deg, #2a1500 0%, #1a0e00 100%);
    border-bottom: 2px solid rgba(255,149,0,0.3);
    padding: 1rem 1.5rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .logo-area h1 {
    font-family: 'Lilita One', cursive;
    font-size: clamp(1.4rem, 4vw, 2rem);
    color: var(--yellow);
    text-shadow: 0 2px 20px rgba(255,214,10,0.4);
    letter-spacing: 0.02em;
  }

  .logo-area .unit-tag {
    font-size: 0.72rem;
    color: var(--orange);
    font-weight: 700;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    margin-top: 0.1rem;
  }

  .stats-row {
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
  }

  .stat-pill {
    background: rgba(255,149,0,0.1);
    border: 1px solid rgba(255,149,0,0.25);
    border-radius: 999px;
    padding: 0.4rem 1rem;
    font-size: 0.85rem;
    font-weight: 800;
    display: flex;
    align-items: center;
    gap: 0.4rem;
  }

  .stat-pill .val { color: var(--yellow); font-size: 1rem; }

  /* ‚îÄ‚îÄ TIMER BAR ‚îÄ‚îÄ */
  .timer-wrap {
    width: 100%;
    max-width: 700px;
    padding: 0.8rem 1.5rem 0;
  }

  .timer-track {
    width: 100%;
    height: 8px;
    background: rgba(255,255,255,0.08);
    border-radius: 4px;
    overflow: hidden;
  }

  .timer-fill {
    height: 100%;
    border-radius: 4px;
    background: linear-gradient(90deg, var(--green), var(--yellow), var(--orange), var(--red));
    background-size: 300% 100%;
    background-position: 0% 0%;
    transition: width 0.1s linear, background-position 0.5s;
    width: 100%;
  }

  .timer-label {
    text-align: right;
    font-family: 'Lilita One', cursive;
    font-size: 0.85rem;
    color: var(--muted);
    margin-top: 0.3rem;
  }

  .timer-label span { color: var(--yellow); font-size: 1rem; }

  /* ‚îÄ‚îÄ MAIN STAGE ‚îÄ‚îÄ */
  .stage {
    width: 100%;
    max-width: 700px;
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.5rem;
    flex: 1;
  }

  /* ‚îÄ‚îÄ WORD CARD ‚îÄ‚îÄ */
  .word-card {
    width: 100%;
    background: var(--surface);
    border: 2px solid rgba(255,149,0,0.2);
    border-radius: 20px;
    padding: 1.8rem 2rem;
    text-align: center;
    position: relative;
    overflow: hidden;
    min-height: 180px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    transition: border-color 0.2s;
  }

  .word-card::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse at 50% 0%, rgba(255,149,0,0.06) 0%, transparent 70%);
    pointer-events: none;
  }

  .word-card.correct-flash {
    border-color: var(--green);
    animation: correctPulse 0.4s ease;
  }

  .word-card.wrong-flash {
    border-color: var(--red);
    animation: wrongShake 0.35s ease;
  }

  .word-card.timeout-flash {
    border-color: var(--red);
    animation: timeoutFade 0.5s ease;
  }

  @keyframes correctPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
  }

  @keyframes wrongShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-8px); }
    75% { transform: translateX(8px); }
  }

  @keyframes timeoutFade {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  .definition-label {
    font-size: 0.7rem;
    font-weight: 700;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--orange);
    margin-bottom: -0.5rem;
  }

  .definition-text {
    font-size: clamp(0.95rem, 2.5vw, 1.15rem);
    color: var(--text);
    line-height: 1.5;
    font-weight: 600;
    max-width: 480px;
  }

  /* Word display with blank */
  .word-display {
    display: flex;
    gap: 0.35rem;
    align-items: flex-end;
    flex-wrap: wrap;
    justify-content: center;
  }

  .letter-box {
    width: 38px;
    height: 46px;
    border-bottom: 3px solid rgba(255,149,0,0.4);
    display: flex;
    align-items: flex-end;
    justify-content: center;
    padding-bottom: 4px;
    position: relative;
  }

  .letter-box.blank-box {
    border-bottom-color: var(--yellow);
    background: rgba(255,214,10,0.08);
    border-radius: 4px 4px 0 0;
  }

  .letter-box.blank-box::after {
    content: '?';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -55%);
    color: rgba(255,214,10,0.4);
    font-family: 'Lilita One', cursive;
    font-size: 1.1rem;
    animation: pulse 1s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.4; }
    50% { opacity: 1; }
  }

  .letter-box.blank-box.filled::after { display: none; }

  .letter-char {
    font-family: 'Lilita One', cursive;
    font-size: 1.4rem;
    color: var(--text);
    text-transform: uppercase;
    line-height: 1;
  }

  .letter-char.blank-char {
    color: var(--yellow);
    animation: charPop 0.3s cubic-bezier(0.175,0.885,0.32,1.275);
  }

  @keyframes charPop {
    from { transform: scale(0) rotate(-15deg); opacity: 0; }
    to   { transform: scale(1) rotate(0deg); opacity: 1; }
  }

  /* Hint: category */
  .hint-row {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    font-size: 0.78rem;
    color: var(--muted);
    font-weight: 600;
  }

  .hint-row .category-badge {
    background: rgba(0,229,200,0.1);
    border: 1px solid rgba(0,229,200,0.25);
    color: var(--teal);
    padding: 0.2rem 0.7rem;
    border-radius: 999px;
    font-size: 0.7rem;
    font-weight: 700;
    letter-spacing: 0.08em;
  }

  /* ‚îÄ‚îÄ KEYBOARD ‚îÄ‚îÄ */
  .keyboard-area {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.4rem;
  }

  .kb-row {
    display: flex;
    gap: 0.35rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  .key {
    width: clamp(32px, 8vw, 42px);
    height: clamp(38px, 10vw, 48px);
    background: var(--surface2);
    border: 1.5px solid rgba(255,149,0,0.2);
    border-radius: 8px;
    color: var(--text);
    font-family: 'Nunito', sans-serif;
    font-size: clamp(0.8rem, 2vw, 1rem);
    font-weight: 800;
    cursor: pointer;
    transition: all 0.1s;
    display: flex;
    align-items: center;
    justify-content: center;
    text-transform: uppercase;
    user-select: none;
    position: relative;
    overflow: hidden;
  }

  .key::after {
    content: '';
    position: absolute;
    inset: 0;
    background: rgba(255,149,0,0);
    transition: background 0.1s;
  }

  .key:hover:not(.used) {
    background: rgba(255,149,0,0.15);
    border-color: var(--orange);
    color: var(--yellow);
    transform: translateY(-3px);
    box-shadow: 0 4px 12px rgba(255,149,0,0.2);
  }

  .key:active:not(.used) { transform: translateY(0); }

  .key.correct-key {
    background: rgba(52,199,89,0.2);
    border-color: var(--green);
    color: var(--green);
    cursor: default;
  }

  .key.wrong-key {
    background: rgba(255,59,48,0.1);
    border-color: rgba(255,59,48,0.2);
    color: rgba(255,59,48,0.35);
    cursor: default;
    transform: none;
  }

  /* ‚îÄ‚îÄ FEEDBACK BUBBLE ‚îÄ‚îÄ */
  .feedback {
    height: 2.2rem;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Lilita One', cursive;
    font-size: 1.1rem;
    transition: opacity 0.3s;
  }

  .feedback.correct { color: var(--green); }
  .feedback.wrong   { color: var(--red); }
  .feedback.timeout { color: var(--orange); }

  /* ‚îÄ‚îÄ SCORE OVERLAY ‚îÄ‚îÄ */
  .overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(20,12,0,0.92);
    backdrop-filter: blur(10px);
    z-index: 200;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 1rem;
    padding: 2rem;
  }

  .overlay.show { display: flex; animation: fadeIn 0.4s ease; }
  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

  .result-card {
    background: var(--surface);
    border: 2px solid rgba(255,149,0,0.3);
    border-radius: 24px;
    padding: 2.5rem 2.5rem;
    text-align: center;
    max-width: 400px;
    width: 100%;
  }

  .result-emoji { font-size: 3.5rem; margin-bottom: 0.5rem; }

  .result-title {
    font-family: 'Lilita One', cursive;
    font-size: 2rem;
    color: var(--yellow);
    margin-bottom: 0.5rem;
  }

  .result-score {
    font-size: 3rem;
    font-weight: 900;
    color: var(--text);
    margin: 0.5rem 0;
  }

  .result-score span { color: var(--orange); font-size: 1.5rem; }

  .result-breakdown {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin: 1rem 0;
    flex-wrap: wrap;
  }

  .result-stat {
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    padding: 0.6rem 1rem;
    font-size: 0.85rem;
    font-weight: 700;
  }

  .result-stat .rs-val { font-size: 1.3rem; display: block; }
  .result-stat .rs-label { color: var(--muted); font-size: 0.72rem; }

  .btn-restart {
    margin-top: 1rem;
    background: var(--orange);
    color: #1a0e00;
    border: none;
    border-radius: 12px;
    padding: 0.9rem 2.5rem;
    font-family: 'Lilita One', cursive;
    font-size: 1.1rem;
    cursor: pointer;
    transition: all 0.15s;
    letter-spacing: 0.05em;
  }

  .btn-restart:hover {
    background: var(--yellow);
    transform: translateY(-2px);
    box-shadow: 0 6px 24px rgba(255,149,0,0.4);
  }

  /* ‚îÄ‚îÄ WAITING STATE ‚îÄ‚îÄ */
  .waiting-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.5rem;
    padding: 2rem 0;
  }

  .waiting-state h2 {
    font-family: 'Lilita One', cursive;
    font-size: clamp(1.5rem, 4vw, 2.2rem);
    color: var(--yellow);
    text-align: center;
    line-height: 1.2;
  }

  .waiting-state p {
    color: var(--muted);
    font-size: 0.95rem;
    text-align: center;
    max-width: 400px;
    line-height: 1.6;
  }

  .btn-start {
    background: linear-gradient(135deg, var(--orange), #ff6b00);
    color: white;
    border: none;
    border-radius: 14px;
    padding: 1rem 3rem;
    font-family: 'Lilita One', cursive;
    font-size: 1.3rem;
    cursor: pointer;
    transition: all 0.15s;
    letter-spacing: 0.05em;
    box-shadow: 0 4px 20px rgba(255,149,0,0.3);
  }

  .btn-start:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 30px rgba(255,149,0,0.5);
  }

  .how-to {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 1.2rem 1.5rem;
    max-width: 420px;
    width: 100%;
  }

  .how-to h3 {
    font-size: 0.72rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--orange);
    font-weight: 700;
    margin-bottom: 0.8rem;
  }

  .how-to-steps {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .how-step {
    display: flex;
    gap: 0.8rem;
    align-items: flex-start;
    font-size: 0.88rem;
    color: var(--muted);
    line-height: 1.4;
  }

  .how-step .step-num {
    background: rgba(255,149,0,0.15);
    color: var(--orange);
    border-radius: 50%;
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.72rem;
    font-weight: 900;
    flex-shrink: 0;
    margin-top: 1px;
  }

  /* Floating particles when correct */
  .particle {
    position: fixed;
    pointer-events: none;
    z-index: 300;
    font-size: 1.5rem;
    animation: floatParticle 1s ease forwards;
  }

  @keyframes floatParticle {
    0%   { transform: translateY(0) scale(1); opacity: 1; }
    100% { transform: translateY(-120px) scale(0.3); opacity: 0; }
  }

  /* Progress dots */
  .progress-dots {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 400px;
  }

  .dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.15);
    transition: all 0.3s;
  }

  .dot.done-correct { background: var(--green); border-color: var(--green); }
  .dot.done-wrong   { background: var(--red); border-color: var(--red); }
  .dot.current      { background: var(--yellow); border-color: var(--yellow); box-shadow: 0 0 8px rgba(255,214,10,0.6); }
</style>
</head>
<body>

<header>
  <div class="logo-area">
    <h1>üçú Whack-a-Word</h1>
    <div class="unit-tag">Tle AGORA ¬∑ Unit 5 ‚Äî The Nomad Kitchen</div>
  </div>
  <div class="stats-row">
    <div class="stat-pill">üéØ <span class="val" id="stat-score">0</span> pts</div>
    <div class="stat-pill">üî• <span class="val" id="stat-streak">0</span> streak</div>
    <div class="stat-pill">‚úÖ <span class="val" id="stat-correct">0</span> / <span class="val" id="stat-total">0</span></div>
  </div>
</header>

<div class="timer-wrap" id="timer-wrap" style="display:none">
  <div class="timer-track"><div class="timer-fill" id="timer-fill"></div></div>
  <div class="timer-label">‚è± <span id="timer-val">8</span>s</div>
</div>

<div class="stage" id="stage">
  <!-- Waiting state -->
  <div class="waiting-state" id="waiting-state">
    <h2>üåç The Nomad Kitchen<br>Word Challenge!</h2>
    <p>A word appears with its definition. One letter is missing ‚Äî find it before time runs out! üî•</p>
    <div class="how-to">
      <h3>How to play</h3>
      <div class="how-to-steps">
        <div class="how-step"><span class="step-num">1</span><span>Read the definition carefully</span></div>
        <div class="how-step"><span class="step-num">2</span><span>Find the missing letter in the word</span></div>
        <div class="how-step"><span class="step-num">3</span><span>Click the right letter before time runs out!</span></div>
        <div class="how-step"><span class="step-num">4</span><span>Score big, build your streak üî•</span></div>
      </div>
    </div>
    <button class="btn-start" onclick="startGame()">Let's go! üöÄ</button>
  </div>

  <!-- Game state (hidden initially) -->
  <div id="game-state" style="display:none; width:100%; display:none; flex-direction:column; align-items:center; gap:1.2rem;">
    <div class="progress-dots" id="progress-dots"></div>
    <div class="word-card" id="word-card">
      <div class="definition-label">Definition</div>
      <div class="definition-text" id="def-text">‚Äî</div>
      <div class="word-display" id="word-display"></div>
      <div class="hint-row">
        <span>Category:</span>
        <span class="category-badge" id="cat-badge">‚Äî</span>
      </div>
    </div>
    <div class="feedback" id="feedback"></div>
    <div class="keyboard-area" id="keyboard"></div>
  </div>
</div>

<!-- Result overlay -->
<div class="overlay" id="overlay">
  <div class="result-card">
    <div class="result-emoji" id="result-emoji">üéâ</div>
    <div class="result-title" id="result-title">Well done!</div>
    <div class="result-score" id="result-score">0 <span>pts</span></div>
    <div class="result-breakdown" id="result-breakdown"></div>
    <button class="btn-restart" onclick="restartGame()">Play again üîÑ</button>
  </div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// VOCABULARY ‚Äî Unit 5 The Nomad Kitchen
// Terminale AGORA / B1-B2
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const WORDS = [
  // Lesson 1 ‚Äî Street Food Around the World
  { word: 'SPICY',      def: 'Having a strong, hot flavour (like chili or pepper)',         cat: 'üå∂ Adjectives' },
  { word: 'SWEET',      def: 'Having the taste of sugar or honey',                          cat: 'üå∂ Adjectives' },
  { word: 'SALTY',      def: 'Having the taste of salt',                                    cat: 'üå∂ Adjectives' },
  { word: 'POPULAR',    def: 'Liked or enjoyed by many people',                             cat: 'üå∂ Adjectives' },
  { word: 'TYPICAL',    def: 'Representative of a country or culture',                      cat: 'üå∂ Adjectives' },
  { word: 'DISH',       def: 'A type of food prepared in a particular way',                 cat: 'üçú Food vocab' },
  { word: 'COUNTRY',    def: 'A nation with its own government and territory',              cat: 'üåç Places' },
  // Lesson 2 ‚Äî The Rise of the Food Truck
  { word: 'TRUCK',      def: 'A large vehicle used to transport or sell goods',             cat: 'üöö Food Trucks' },
  { word: 'MOBILE',     def: 'Able to move from one place to another',                     cat: 'üöö Food Trucks' },
  { word: 'CRISIS',     def: 'A time of great difficulty or danger',                       cat: 'üì∞ Text vocab' },
  { word: 'CAPITAL',    def: 'Money used to start or run a business',                      cat: 'üíº Business' },
  { word: 'ARTISAN',    def: 'Made by hand with great skill and care',                     cat: 'üì∞ Text vocab' },
  { word: 'BARRIER',    def: 'An obstacle that makes something difficult',                  cat: 'üì∞ Text vocab' },
  { word: 'CULINARY',   def: 'Related to cooking and food preparation',                    cat: 'üçú Food vocab' },
  { word: 'GOURMET',    def: 'High quality food with refined taste',                       cat: 'üçú Food vocab' },
  // Lesson 3 ‚Äî Immigration & New York
  { word: 'IMMIGRANT',  def: 'A person who comes to live in a new country',                cat: 'üåç Society' },
  { word: 'DECADE',     def: 'A period of ten years',                                      cat: '‚è≥ Time' },
  { word: 'CULTURE',    def: 'The customs, arts and traditions of a society',              cat: 'üåç Society' },
  { word: 'STREET',     def: 'A public road in a town or city',                            cat: 'üèô Places' },
  // Mystery Dish game vocab
  { word: 'FRIED',      def: 'Cooked in hot oil or fat',                                   cat: 'üçú Food vocab' },
  { word: 'GRILLED',    def: 'Cooked over or under direct heat',                           cat: 'üçú Food vocab' },
  { word: 'SNACK',      def: 'A small amount of food eaten between meals',                 cat: 'üçú Food vocab' },
  { word: 'RECIPE',     def: 'Instructions for preparing a particular dish',               cat: 'üçú Food vocab' },
  { word: 'VENDOR',     def: 'A person who sells goods, often in the street',              cat: 'üíº Business' },
  { word: 'ORIGIN',     def: 'The point or place where something began',                   cat: 'üåç Society' },
];

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GAME STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const ROUND_COUNT = 12;
const TIME_LIMIT  = 8; // seconds per word

let queue = [];
let currentIdx = 0;
let currentWord = null;
let blankPos = 0;
let timer = null;
let timeLeft = 0;
let score = 0;
let streak = 0;
let correctCount = 0;
let results = []; // true/false per round

const KB_ROWS = ['QWERTYUIOP', 'ASDFGHJKL', 'ZXCVBNM'];

function shuffle(arr) { return [...arr].sort(() => Math.random() - 0.5); }

function buildQueue() {
  // Pick ROUND_COUNT words, shuffle, pick smart blank positions
  const pool = shuffle(WORDS).slice(0, ROUND_COUNT);
  queue = pool.map(w => {
    // Avoid first/last, pick a "meaty" letter position
    const candidates = [];
    for (let i = 1; i < w.word.length - 1; i++) candidates.push(i);
    const pos = candidates[Math.floor(Math.random() * candidates.length)] ?? 1;
    return { ...w, blankPos: pos };
  });
}

function startGame() {
  buildQueue();
  currentIdx = 0;
  score = 0;
  streak = 0;
  correctCount = 0;
  results = [];
  updateStats();

  document.getElementById('waiting-state').style.display = 'none';
  const gs = document.getElementById('game-state');
  gs.style.display = 'flex';
  document.getElementById('timer-wrap').style.display = 'block';

  buildProgressDots();
  nextWord();
}

function buildProgressDots() {
  const wrap = document.getElementById('progress-dots');
  wrap.innerHTML = '';
  for (let i = 0; i < ROUND_COUNT; i++) {
    const d = document.createElement('div');
    d.className = 'dot' + (i === 0 ? ' current' : '');
    d.id = `dot-${i}`;
    wrap.appendChild(d);
  }
}

function nextWord() {
  if (currentIdx >= ROUND_COUNT) { endGame(); return; }

  clearInterval(timer);
  const entry = queue[currentIdx];
  currentWord = entry;
  blankPos = entry.blankPos;

  // Update dots
  if (currentIdx > 0) {
    const prev = document.getElementById(`dot-${currentIdx - 1}`);
    if (prev) prev.classList.remove('current');
  }
  const cur = document.getElementById(`dot-${currentIdx}`);
  if (cur) { cur.classList.add('current'); }

  // Render definition
  document.getElementById('def-text').textContent = entry.def;
  document.getElementById('cat-badge').textContent = entry.cat;

  // Render word display
  renderWordDisplay(entry.word, blankPos, null);

  // Reset card
  const card = document.getElementById('word-card');
  card.className = 'word-card';

  // Clear feedback
  const fb = document.getElementById('feedback');
  fb.textContent = '';
  fb.className = 'feedback';

  // Build keyboard
  renderKeyboard();

  // Start timer
  timeLeft = TIME_LIMIT;
  updateTimerBar();
  timer = setInterval(() => {
    timeLeft -= 0.1;
    updateTimerBar();
    if (timeLeft <= 0) {
      clearInterval(timer);
      handleTimeout();
    }
  }, 100);

  document.getElementById('stat-total').textContent = ROUND_COUNT;
}

function renderWordDisplay(word, blank, filledLetter) {
  const wrap = document.getElementById('word-display');
  wrap.innerHTML = '';
  word.split('').forEach((ch, i) => {
    const box = document.createElement('div');
    box.className = 'letter-box';
    const span = document.createElement('span');
    span.className = 'letter-char';
    if (i === blank) {
      box.classList.add('blank-box');
      if (filledLetter) {
        box.classList.add('filled');
        span.textContent = filledLetter;
        span.classList.add('blank-char');
      }
    } else {
      span.textContent = ch;
    }
    box.appendChild(span);
    wrap.appendChild(box);
  });
}

function renderKeyboard() {
  const kb = document.getElementById('keyboard');
  kb.innerHTML = '';
  KB_ROWS.forEach(row => {
    const div = document.createElement('div');
    div.className = 'kb-row';
    row.split('').forEach(ch => {
      const btn = document.createElement('div');
      btn.className = 'key';
      btn.textContent = ch;
      btn.id = `key-${ch}`;
      btn.addEventListener('click', () => guess(ch));
      div.appendChild(btn);
    });
    kb.appendChild(div);
  });
}

function guess(ch) {
  if (!currentWord) return;
  clearInterval(timer);

  const correct = currentWord.word[blankPos];
  const isCorrect = ch === correct;

  // Disable all keys
  document.querySelectorAll('.key').forEach(k => {
    k.style.pointerEvents = 'none';
    if (k.textContent === ch) {
      k.classList.add(isCorrect ? 'correct-key' : 'wrong-key');
    }
  });

  if (isCorrect) {
    handleCorrect(ch);
  } else {
    handleWrong(ch, correct);
  }
}

function handleCorrect(ch) {
  streak++;
  const bonus = streak >= 3 ? Math.floor(streak * 0.5) : 0;
  const pts = 10 + bonus + Math.floor(timeLeft);
  score += pts;
  correctCount++;

  results.push(true);
  markDot(currentIdx, true);

  // Fill blank
  renderWordDisplay(currentWord.word, blankPos, ch);

  // Flash card
  document.getElementById('word-card').classList.add('correct-flash');

  // Feedback
  const fb = document.getElementById('feedback');
  fb.className = 'feedback correct';
  fb.textContent = streak >= 3
    ? `üî• ${streak} streak! +${pts} pts`
    : `‚úÖ Correct! +${pts} pts`;

  // Particles
  spawnParticles();
  updateStats();

  setTimeout(() => {
    currentIdx++;
    nextWord();
  }, 900);
}

function handleWrong(ch, correct) {
  streak = 0;
  results.push(false);
  markDot(currentIdx, false);

  // Show correct letter
  renderWordDisplay(currentWord.word, blankPos, correct);

  // Flash card
  document.getElementById('word-card').classList.add('wrong-flash');

  // Mark correct key
  const ck = document.getElementById(`key-${correct}`);
  if (ck) ck.classList.add('correct-key');

  const fb = document.getElementById('feedback');
  fb.className = 'feedback wrong';
  fb.textContent = `‚ùå It was "${correct}"`;

  updateStats();

  setTimeout(() => {
    currentIdx++;
    nextWord();
  }, 1200);
}

function handleTimeout() {
  streak = 0;
  results.push(false);
  markDot(currentIdx, false);

  const correct = currentWord.word[blankPos];
  renderWordDisplay(currentWord.word, blankPos, correct);

  document.getElementById('word-card').classList.add('timeout-flash');

  // Disable keys
  document.querySelectorAll('.key').forEach(k => {
    k.style.pointerEvents = 'none';
    if (k.textContent === correct) k.classList.add('correct-key');
  });

  const fb = document.getElementById('feedback');
  fb.className = 'feedback timeout';
  fb.textContent = `‚è∞ Time's up! It was "${correct}"`;

  updateStats();

  setTimeout(() => {
    currentIdx++;
    nextWord();
  }, 1200);
}

function markDot(idx, correct) {
  const dot = document.getElementById(`dot-${idx}`);
  if (dot) {
    dot.classList.remove('current');
    dot.classList.add(correct ? 'done-correct' : 'done-wrong');
  }
}

function updateTimerBar() {
  const pct = Math.max(0, (timeLeft / TIME_LIMIT) * 100);
  const fill = document.getElementById('timer-fill');
  fill.style.width = `${pct}%`;
  // Shift gradient red as time runs out
  fill.style.backgroundPosition = `${100 - pct}% 0%`;
  document.getElementById('timer-val').textContent = Math.ceil(timeLeft);
}

function updateStats() {
  document.getElementById('stat-score').textContent = score;
  document.getElementById('stat-streak').textContent = streak;
  document.getElementById('stat-correct').textContent = correctCount;
}

function spawnParticles() {
  const emojis = ['üå∂', 'üçú', 'üåç', '‚≠ê', 'üî•', '‚ú®'];
  const card = document.getElementById('word-card');
  const rect = card.getBoundingClientRect();
  for (let i = 0; i < 6; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    p.textContent = emojis[Math.floor(Math.random() * emojis.length)];
    p.style.left = (rect.left + Math.random() * rect.width) + 'px';
    p.style.top  = (rect.top + rect.height * 0.5) + 'px';
    p.style.animationDelay = (Math.random() * 0.3) + 's';
    document.body.appendChild(p);
    setTimeout(() => p.remove(), 1200);
  }
}

function endGame() {
  clearInterval(timer);
  document.getElementById('timer-wrap').style.display = 'none';

  const pct = Math.round((correctCount / ROUND_COUNT) * 100);
  let emoji = 'üòÖ', title = 'Keep practising!';
  if (pct >= 90) { emoji = 'üèÜ'; title = 'Outstanding!'; }
  else if (pct >= 70) { emoji = 'üéâ'; title = 'Well done!'; }
  else if (pct >= 50) { emoji = 'üëç'; title = 'Good effort!'; }

  document.getElementById('result-emoji').textContent = emoji;
  document.getElementById('result-title').textContent = title;
  document.getElementById('result-score').innerHTML = `${score} <span>pts</span>`;

  const bd = document.getElementById('result-breakdown');
  bd.innerHTML = `
    <div class="result-stat">
      <span class="rs-val" style="color:var(--green)">${correctCount}</span>
      <span class="rs-label">Correct</span>
    </div>
    <div class="result-stat">
      <span class="rs-val" style="color:var(--red)">${ROUND_COUNT - correctCount}</span>
      <span class="rs-label">Missed</span>
    </div>
    <div class="result-stat">
      <span class="rs-val" style="color:var(--yellow)">${pct}%</span>
      <span class="rs-label">Score</span>
    </div>
  `;

  document.getElementById('overlay').classList.add('show');
}

function restartGame() {
  document.getElementById('overlay').classList.remove('show');
  document.getElementById('timer-wrap').style.display = 'block';
  startGame();
}

// Keyboard support
document.addEventListener('keydown', e => {
  if (e.key.length === 1 && /[a-zA-Z]/.test(e.key) && currentWord) {
    guess(e.key.toUpperCase());
  }
});
</script>
</body>
</html>
